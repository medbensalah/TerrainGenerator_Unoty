// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Perlin
#include "UnityCG.cginc"

RWTexture2D<float> Result;

// ---------------------------------------------------------
//                      Settings
// ---------------------------------------------------------

float _terrainSize;
float2 _offset;
uint _seed;

int _octaves;
float _persistence;
float _lacunarity;
float _scale;


uint Hash_1_1_uint(uint s)
{
    s ^= 2747636419u;
    s *= 2654435769u;
    s ^= s >> 16;
    s *= 2654435769u;
    s ^= s >> 16;
    s *= 2654435769u;
    return s;
}

float Hash_2_1_float (float2 uv)
{
    return frac(sin(dot(uv,float2(12.9898,78.233)))*43758.5453123);
}

void Hash_2_1_uint(uint2 v, out uint o)
{
    // ~6 alu (2 mul)
    v.y ^= 1103515245U;
    v.x += v.y;
    v.x *= v.y;
    v.x ^= v.x >> 5u;
    v.x *= 0x27d4eb2du;
    o = v.x;
}

void Hash_2_1_float(float2 i, out float o)
{
    uint r;
    uint2 v = (uint2) (int2) round(i);
    Hash_2_1_uint(v, r);
    o = r * (1.0 / float(0xffffffff));
}

float2 GradientNoise_Deterministic_Dir_float(float2 p)
{
    float x; Hash_2_1_float(p, x);
    return normalize(float2(x - floor(x + 0.5), abs(x) - 0.5));
}

void Unity_GradientNoise_Deterministic_float (float2 UV, float3 Scale, out float Out)
{
    float2 p = UV * Scale.xy;
    float2 ip = floor(p);
    float2 fp = frac(p);
    float d00 = dot(GradientNoise_Deterministic_Dir_float(ip), fp);
    float d01 = dot(GradientNoise_Deterministic_Dir_float(ip + float2(0, 1)), fp - float2(0, 1));
    float d10 = dot(GradientNoise_Deterministic_Dir_float(ip + float2(1, 0)), fp - float2(1, 0));
    float d11 = dot(GradientNoise_Deterministic_Dir_float(ip + float2(1, 1)), fp - float2(1, 1));
    fp = fp * fp * fp * (fp * (fp * 6 - 15) + 10);
    Out = lerp(lerp(d00, d01, fp.y), lerp(d10, d11, fp.y), fp.x) + 0.3;
}

float SurfaceDescriptionFunction(float2 uv)
{
    float value;
    Unity_GradientNoise_Deterministic_float(uv, float3(1,1 ,1), value);
    float Out = value < 1.0f ? value : 1.0f;
    return Out;
}


[numthreads(8,8,1)]
void Perlin(uint3 id : SV_DispatchThreadID)
{
    float h = 0.5;
    float _frequency = 1.0f;
    float _amplitude = 1.0f;
    for (int i = 0; i < _octaves; i++)
    {
        float2 uv = id.xy /_terrainSize;
        float2 randomOffset = float2(Hash_1_1_uint(_seed + i), Hash_1_1_uint(_seed + i + 1)) / 1000000.0f;
        float2 sampling_uv = ((uv - 0.5f) *_scale + randomOffset + _offset) * _frequency;
        float noise = SurfaceDescriptionFunction(sampling_uv) * 2.0f - 1.0f;
        h += noise * _amplitude;

        _amplitude *= _persistence;
        _frequency *= _lacunarity;
    }

    h = h * 0.5f + 0.5f;
    Result[id.xy] = PackHeightmap(saturate(h) * 0.5f).x;
}

